
#include "wsola.h"

#if defined(WIN32)
typedef __int64 INT64;
typedef unsigned __int64 UNIT64; 
#else
typedef long long INT64;
typedef unsigned long long UNIT64; 
#endif

/**
 * Specify the default maximum duration of synthetic audio that is generated
 * by WSOLA. This value should be long enough to cover burst of packet losses. 
 * but not too long, because as the duration increases the quality would 
 * degrade considerably.
 *
 * Note that this limit is only applied when fading is enabled in the WSOLA
 * session.
 *
 * Default: 80
 */
#define WSOLA_MAX_EXPAND_MSEC    80


/**
 * Specify WSOLA template length, in milliseconds. The longer the template,
 * the smoother signal to be generated at the expense of more computation
 * needed, since the algorithm will have to compare more samples to find
 * the most similar pitch.
 *
 * Default: 5
 */
#define WSOLA_TEMPLATE_LENGTH_MSEC	5


/**
 * Specify WSOLA algorithm delay, in milliseconds. The algorithm delay is
 * used to merge synthetic samples with real samples in the transition
 * between real to synthetic and vice versa. The longer the delay, the 
 * smoother signal to be generated, at the expense of longer latency and
 * a slighty more computation.
 * Hanning window size, in msec
 *
 * Default: 5
 */
#define WSOLA_DELAY_MSEC	    5


/**
 * Set this to non-zero to disable fade-out/in effect in the PLC when it
 * instructs WSOLA to generate synthetic frames. The use of fading may
 * or may not improve the quality of audio, depending on the nature of
 * packet loss and the type of audio input (e.g. speech vs music).
 * Disabling fading also implicitly remove the maximum limit of synthetic
 * audio samples generated by WSOLA (see WSOLA_MAX_EXPAND_MSEC).
 *
 * Default: 0
 */
#define WSOLA_PLC_NO_FADING	    0

/* Buffer size including history, in frames */
#define FRAME_CNT				6

/* Number of history frames in buffer */
#define HIST_CNT				1.5

/* Number of frames in erase buffer */
#define ERASE_CNT				((DWORD)3)

/* Minimum distance from template for WsolaFindPitch() of expansion, in frames */
#define EXP_MIN_DIST			0.5

/* Maximum distance from template for WsolaFindPitch() of expansion, in frames */
#define EXP_MAX_DIST			HIST_CNT




/* In this implementation, waveform similarity comparison is done by calculating
 * the difference of total level between template frame and the target buffer 
 * for each template_cnt samples. The smallest difference value assumed to be 
 * the most similar block. This seems to be naive, however some tests show
 * acceptable results and the processing speed is amazing.
 *
 * diff level = (template[1]+..+template[n]) - (target[1]+..+target[n])
 */
static short *WsolaFindPitchLite(short *frm, short *beg, short *end, 
			 DWORD template_cnt, int first)
{
	short *sr, *best=beg;
	int best_corr = 0x7FFFFFFF;
	int frm_sum = 0;
	DWORD i;
	
	for (i = 0; i<template_cnt; ++i)
		frm_sum += frm[i];
	
	for (sr=beg; sr!=end; ++sr)
	{
		int corr = frm_sum;
		int abs_corr = 0;
		
		/* Do calculation on 8 samples at once */
		for (i = 0; i<template_cnt-8; i+=8) 
		{
			corr -= (int)sr[i+0] +
				(int)sr[i+1] +
				(int)sr[i+2] +
				(int)sr[i+3] +
				(int)sr[i+4] +
				(int)sr[i+5] +
				(int)sr[i+6] +
				(int)sr[i+7];
		}
		
		/* Process remaining samples */
		for (; i<template_cnt; ++i)
			corr -= (int)sr[i];
		
		abs_corr = corr > 0? corr : -corr;
		
		if (first)
		{
			if (abs_corr < best_corr) 
			{
				best_corr = abs_corr;
				best = sr;
			}
		}
		else 
		{
			if (abs_corr <= best_corr) 
			{
				best_corr = abs_corr;
				best = sr;
			}
		}
	}
	
	/*kprintf("found pitch at %u", best-beg));*/
	return best;
}


#define WINDOW_BITS	15
#define WINDOW_MAX_VAL  ((1<<WINDOW_BITS)-1)
/*
 * Fixed point version.
 */
static short *WsolaFindPitch(short *frm, short *beg, short *end, 
			 DWORD template_cnt, int first)
{
	short *sr, *best=beg;
	INT64 best_corr = 0;

	
	for (sr=beg; sr!=end; ++sr) 
	{
		INT64 corr = 0;
		DWORD i;
		
		/* Do calculation on 8 samples at once */
		for (i=0; i<template_cnt-8; i+=8) 
		{
			corr += ((int)frm[i+0]) * ((int)sr[i+0]) + 
				((int)frm[i+1]) * ((int)sr[i+1]) + 
				((int)frm[i+2]) * ((int)sr[i+2]) +
				((int)frm[i+3]) * ((int)sr[i+3]) +
				((int)frm[i+4]) * ((int)sr[i+4]) +
				((int)frm[i+5]) * ((int)sr[i+5]) +
				((int)frm[i+6]) * ((int)sr[i+6]) +
				((int)frm[i+7]) * ((int)sr[i+7]);
		}
		
		/* Process remaining samples. */
		for (; i<template_cnt; ++i) 
		{
			corr += ((int)frm[i]) * ((int)sr[i]);
		}
		
		if (first) 
		{
			if (corr > best_corr)
			{
				best_corr = corr;
				best = sr;
			}
		} 
		else 
		{
			if (corr >= best_corr)
			{
				best_corr = corr;
				best = sr;
			}
		}
	}
	
	/*kprintf("found pitch at %u", best-beg));*/
	return best;
}


static void WsolaOverlapAdd(short dst[], DWORD count,
			 short l[], short r[], WORD w[])
{
	DWORD i;

	for (i=0; i<count; ++i) 
	{
		dst[i] = (short)(((int)(l[i]) * (int)(w[count-1-i]) + 
						  (int)(r[i]) * (int)(w[i])) >> WINDOW_BITS);
	}
}

static void WsolaOverlapAddSimple(short dst[], DWORD count, short l[], short r[])
{
	int step = ((WINDOW_MAX_VAL+1) / count), 
	stepdown = WINDOW_MAX_VAL;
	DWORD i;

	for (i=0; i<count; ++i)
	{
		dst[i]=(short)((l[i] * stepdown + r[i] * (1-stepdown)) >> WINDOW_BITS);
		stepdown -= step;
	}
}

/* WsolaApproxCos():
 *   see: http://www.audiomulch.com/~rossb/code/sinusoids/ 
 */
static DWORD WsolaApproxCos(DWORD x)
{
	DWORD i,j,k;
	
	if( x == 0 )
		return 0xFFFFFFFF;
	
	i = x << 1;
	k = ((x + 0xBFFFFFFD) & 0x80000000) >> 30;
	j = i - i * ((i & 0x80000000)>>30);
	j = j >> 15;
	j = (j * j + j) >> 1;
	j = j - j * k;
	
	return j;
}

static void WsolaWinCreate(WORD **pw, DWORD count)
{
	
	DWORD i;
	WORD *w = (WORD*)WsolaPortMalloc(count*sizeof(WORD));
	
	*pw = w;
	for (i=0; i<count; i++) 
	{
		DWORD phase;
		UNIT64 cos_val;
		
		/* w[i] = (float)(0.5 - 0.5 * cos(2.0 * RC_PI * i / (count*2-1)) ); */
		phase = (DWORD)((UNIT64)(0xFFFFFFFF) * i / (count*2-1));
		cos_val = WsolaApproxCos(phase);
		
		w[i] = (WORD)(WINDOW_MAX_VAL - 
			(WINDOW_MAX_VAL * cos_val) / 0xFFFFFFFF);
	}
}

static void WsolaWinCreateLinear(WORD **pw, DWORD count)
{
	
	DWORD i;
	WORD *w = (WORD*)WsolaPortMalloc(count*sizeof(WORD));
	
	*pw = w;
	for (i=0; i<count; i++) 
	{
		/* Revert to linear */
		w[i] = (WORD)(i * WINDOW_MAX_VAL / count);
	}
}

static void WsolaWinDestroy(WORD *pw)
{
	if(pw)
		WsolaPortFree(pw);
}


/* Apply fade-in to the buffer.
 *  - fade_cnt is the number of samples on which the volume
 *	   will go from zero to 100%
 *  - fade_pos is current sample position within fade_cnt range.
 *	   It is zero for the first sample, so the first sample will
 *	 have zero volume. This value is increasing.
 */
static void WsolaFadeIn(short buf[], int count, int fade_in_pos, int fade_cnt)
{
	int fade_pos = fade_in_pos;

	if (fade_cnt - fade_pos < count) 
	{
		for (; fade_pos < fade_cnt; ++fade_pos, ++buf)
		{
			*buf = (short)(*buf * fade_pos / fade_cnt);
		}
		/* Leave the remaining samples as is */
	} 
	else
	{
		short *end = buf + count;
		for (; buf != end; ++fade_pos, ++buf) 
		{
			*buf = (short)(*buf * fade_pos / fade_cnt);
		}
	}
}

/* Apply fade-out to the buffer. */
static void WsolaFadeOut(WSOLA_OBJECT *wsola, short buf[], int count)
{
	short *end = buf + count;
	int fade_cnt = wsola->max_expand_cnt;
	int fade_pos = wsola->fade_out_pos;

	if (wsola->fade_out_pos == 0) 
	{
		WsolaPortZeroSamples(buf, count);
	}
	else if (fade_pos < count)
	{
		for (; fade_pos; --fade_pos, ++buf)
		{
			*buf = (short)(*buf * fade_pos / fade_cnt);
		}
		if (buf != end)
			WsolaPortZeroSamples(buf, end - buf);
		wsola->fade_out_pos = 0;
	}
	else 
	{
		for (; buf != end; --fade_pos, ++buf)
		{
			*buf = (short)(*buf * fade_pos / fade_cnt);
		}
		wsola->fade_out_pos -= count;
	}
}


HANDLE WsolaCreate(DWORD sample_rate, DWORD channel_count, DWORD options, int rate)
{
	WSOLA_OBJECT *wsola;
	DWORD samples_per_frame;
	int status;

	if((sample_rate != 8000) && (sample_rate != 11025) 
		&& (sample_rate != 16000) && (sample_rate != 22050) 
		&& (sample_rate != 32000) && (sample_rate != 44100) 
		&& (sample_rate != 24000) && (sample_rate != 48000))
		return NULL;
	if((channel_count != 1) && (channel_count != 2))
		return NULL;
	if((rate > 10) || (rate < -5))
		return NULL;
	samples_per_frame =  (sample_rate / 100);
	samples_per_frame &= 0xfffffffc;

	/* Allocate wsola and initialize vars */
	wsola = WsolaPortMalloc(sizeof(WSOLA_OBJECT));
	WsolaPortMemset(wsola, 0x00, sizeof(WSOLA_OBJECT));
	wsola->sample_rate= (WORD) sample_rate;
	wsola->samples_per_frame = (WORD) samples_per_frame;
	wsola->channel_count = (WORD) channel_count;
	wsola->options = (WORD) options;
	wsola->max_expand_cnt = sample_rate * WSOLA_MAX_EXPAND_MSEC / 1000;
	wsola->fade_out_pos = wsola->max_expand_cnt;
	wsola->rate = rate;

	if(WsolaConvCreate(wsola) < 0)
	{
		WsolaDestroy(wsola);
		kprintf("Failed to create conv buf!\n");
		return NULL;
	}
	
	/* Create circular buffer */
	wsola->buf_size = (WORD) (samples_per_frame * FRAME_CNT);
	status = WsolaBufCreate(wsola->buf_size, &wsola->buf);
	if (status != RC_SUCCESS) 
	{
		WsolaDestroy(wsola);
		kprintf("Failed to create circular buf!\n");
		return NULL;
	}
	
	/* Calculate history size */
	wsola->hist_size = (WORD)(HIST_CNT * samples_per_frame);
	
	/* Calculate template size */
	wsola->templ_size = (WORD)(WSOLA_TEMPLATE_LENGTH_MSEC * sample_rate * 
		channel_count / 1000);
	if (wsola->templ_size > samples_per_frame)
		wsola->templ_size = wsola->samples_per_frame;
	
	/* Calculate hanning window size */
	wsola->hanning_size = (WORD)(WSOLA_DELAY_MSEC * sample_rate * 
		channel_count / 1000);
	if (wsola->hanning_size > wsola->samples_per_frame)
		wsola->hanning_size = wsola->samples_per_frame;
	
	if(!(wsola->templ_size <= wsola->hanning_size))
		return NULL;
	
	/* Create merge buffer */
	wsola->merge_buf = (short*) WsolaPortMalloc(wsola->hanning_size * sizeof(short));
	if(!wsola->merge_buf)
	{
		WsolaDestroy(wsola);
		return NULL;
	}
	WsolaPortMemset(wsola->merge_buf, 0x00, wsola->hanning_size * sizeof(short));
	
	/* Setup with PLC */
	if ((options & WSOLA_OPTION_NO_PLC) == 0) 
	{
		wsola->min_extra = wsola->hanning_size;
		wsola->expand_sr_min_dist = (WORD)
			(EXP_MIN_DIST * wsola->samples_per_frame);
		wsola->expand_sr_max_dist = (WORD)
			(EXP_MAX_DIST * wsola->samples_per_frame);
	}
	
	/* Setup with hanning */
	if ((options & WSOLA_OPTION_NO_HANNING) == 0) 
	{
		if(options & WSOLA_OPTION_LINER_WIN)
			WsolaWinCreateLinear(&wsola->hanning, wsola->hanning_size);
		else
			WsolaWinCreate(&wsola->hanning, wsola->hanning_size);
		if(!wsola->hanning)
		{
			WsolaDestroy(wsola);
			return NULL;
		}	
	}
	
	/* Setup with discard */
	if ((options & WSOLA_OPTION_NO_DISCARD) == 0) 
	{
		wsola->erase_buf = (short*)WsolaPortMalloc(samples_per_frame * ERASE_CNT * sizeof(short));
		if(!wsola->erase_buf)
		{
			WsolaDestroy(wsola);
			return NULL;
		}
		WsolaPortMemset(wsola->erase_buf, 0x00, samples_per_frame * ERASE_CNT * sizeof(short));
	}
	
	/* Generate dummy extra */
	WsolaBufSetLen(wsola->buf, wsola->hist_size + wsola->min_extra);
	
	return wsola;
	
}

int WsolaDestroy(HANDLE hwsola)
{
	WSOLA_OBJECT *wsola = (WSOLA_OBJECT*)hwsola;
	if(wsola)
	{
		WsolaWinDestroy(wsola->hanning);
		WsolaBufDestroy(wsola->buf);
		if(wsola->merge_buf)
			WsolaPortFree(wsola->merge_buf);
		if(wsola->erase_buf)
			WsolaPortFree(wsola->erase_buf);
		WsolaConvDestroy(wsola);
		WsolaPortFree(wsola);
	}	
	return RC_SUCCESS;
}


int WsolaSetMaxExpand(HANDLE hwsola, DWORD msec)
{
	WSOLA_OBJECT *wsola= (WSOLA_OBJECT*)hwsola;
	if(!wsola)
		return RC_EINVAL;
	wsola->max_expand_cnt = msec * wsola->sample_rate / 1000;
	return RC_SUCCESS;
}

int WsolaReset(HANDLE hwsola, DWORD options)
{
	WSOLA_OBJECT *wsola= (WSOLA_OBJECT*)hwsola;
	if(!(wsola && options==0))
		return RC_EINVAL;

	WsolaBufReset(wsola->buf);
	WsolaBufSetLen(wsola->buf, wsola->hist_size + wsola->min_extra);
	WsolaPortZeroSamples(wsola->buf->start, wsola->buf->len); 
	wsola->fade_out_pos = wsola->max_expand_cnt;

	return RC_SUCCESS;
}


static int WsolaExpand(WSOLA_OBJECT *wsola, DWORD needed)
{
	DWORD generated = 0;
	DWORD rep;

	short *reg1, *reg2;
	DWORD reg1_len, reg2_len;

	WsolaBufPack(wsola->buf);
	WsolaBufReadRegions(wsola->buf, &reg1, &reg1_len, 
					  &reg2, &reg2_len);

	for (rep=1;; ++rep) 
	{
		short *start, *templ;
		DWORD dist;
		
		templ = reg1 + reg1_len - wsola->hanning_size;
		
		if(wsola->options & WSOLA_OPTION_LITE)
		{
			start = WsolaFindPitchLite(templ, 
				templ - wsola->expand_sr_max_dist, 
				templ - wsola->expand_sr_min_dist,
				wsola->templ_size, 
				1);
		}
		else
		{
			start = WsolaFindPitch(templ, 
				templ - wsola->expand_sr_max_dist, 
				templ - wsola->expand_sr_min_dist,
				wsola->templ_size, 
				1);
		}
		
			/* Should we make sure that "start" is really aligned to
			* channel #0, in case of stereo? Probably not necessary, as
			* WsolaFindPitch() should have found the best match anyway.
		*/
		
		if (wsola->options & WSOLA_OPTION_NO_HANNING)
		{
			WsolaOverlapAddSimple(wsola->merge_buf, wsola->hanning_size, 
				templ, start);
		} 
		else 
		{
			/* Check if pointers are in the valid range */
			WsolaOverlapAdd(wsola->merge_buf, wsola->hanning_size, templ, 
				start, wsola->hanning);
		}
		
		/* How many new samples do we have */
		dist = templ - start;
		
		/* Not enough buffer to hold the result */
		if (reg1_len + dist > wsola->buf_size) 
		{
			kprintf("WSOLA buffer size may be to small!\n");
			return RC_EUNKNOWN;
		}
		
		/* Copy the "tail" (excess frame) to the end */
		WsolaPortMoveSamples(templ + wsola->hanning_size, 
			start + wsola->hanning_size,
			dist);
		
		/* Copy the merged frame */
		WsolaPortCopySamples(templ, wsola->merge_buf, wsola->hanning_size);
		
		/* We have new samples */
		reg1_len += dist;
		WsolaBufSetLen(wsola->buf, reg1_len);
		
		generated += dist;
		
		if (generated >= needed) 
		{
//			kprintf("WSOLA frame expanded after %d iterations", rep);
			break;
		}
	}
	return RC_SUCCESS;
}


static DWORD WsolaCompress(WSOLA_OBJECT *wsola, short *buf, DWORD count, DWORD del_cnt)
{
	DWORD samples_del = 0, rep;
	
	for (rep=1; ; ++rep) 
	{
		short *start, *end;
		DWORD dist;
		
		if (count <= wsola->hanning_size + del_cnt) 
		{
			kprintf("Not enough samples to WsolaCompress!\n");
			return samples_del;
		}
		
		// Make start distance to del_cnt, so discard will be performed in
		// only one iteration.
		//start = buf + (frmsz >> 1);
		start = buf + del_cnt - samples_del;
		end = start + wsola->samples_per_frame;
		
		if (end + wsola->hanning_size > buf + count)
		{
			end = buf+count-wsola->hanning_size;
		}
		
		if(wsola->options & WSOLA_OPTION_LITE)
			start = WsolaFindPitchLite(buf, start, end, wsola->templ_size, 0);
		else
			start = WsolaFindPitch(buf, start, end, wsola->templ_size, 0);
		dist = start - buf;
		
		if (wsola->options & WSOLA_OPTION_NO_HANNING)
		{
			WsolaOverlapAddSimple(buf, wsola->hanning_size, buf, start);
		}
		else 
		{
			WsolaOverlapAdd(buf, wsola->hanning_size, buf, start, wsola->hanning);
		}
		
		WsolaPortMoveSamples(buf + wsola->hanning_size, 
			buf + wsola->hanning_size + dist,
			count - wsola->hanning_size - dist);
		
		count -= dist;
		samples_del += dist;
		
		if (samples_del >= del_cnt)
		{
//			kprintf("Erased %d of %d requested after %d iteration(s)",
//				samples_del, del_cnt, rep);
			break;
		}
	}
	
	return samples_del;
}



int WsolaSave(HANDLE hwsola,  short frm[], int prev_lost)
{
	DWORD buf_len;
	int status;
	WSOLA_OBJECT *wsola= (WSOLA_OBJECT*)hwsola;
	
	buf_len = WsolaBufGetLen(wsola->buf);
	
	/* Update vars */
	//	wsola->ts.u64 += wsola->samples_per_frame;
	
	/* If previous frame was lost, smoothen this frame with the generated one */
	if (prev_lost) 
	{
		short *reg1, *reg2;
		DWORD reg1_len, reg2_len;
		short *ola_left;
		
		/* Trim excessive len */
		if ((int)buf_len > wsola->hist_size + (wsola->min_extra<<1)) 
		{
			buf_len = wsola->hist_size + (wsola->min_extra<<1);
			WsolaBufSetLen(wsola->buf, buf_len);
		}
		
		WsolaBufReadRegions(wsola->buf, &reg1, &reg1_len, 
			&reg2, &reg2_len);
		
		/* Continue applying fade out to the extra samples */
		if ((wsola->options & WSOLA_OPTION_NO_FADING)==0) 
		{
			if (reg2_len == 0)
			{
				WsolaFadeOut(wsola, reg1 + reg1_len - (wsola->min_extra<<1),
					(wsola->min_extra<<1));
			} 
			else if ((int)reg2_len >= (wsola->min_extra<<1)) 
			{
				WsolaFadeOut(wsola, reg2 + reg2_len - (wsola->min_extra<<1),
					(wsola->min_extra<<1));
			} 
			else
			{
				DWORD tmp = (wsola->min_extra<<1) - reg2_len;
				WsolaFadeOut(wsola, reg1 + reg1_len - tmp, tmp);
				WsolaFadeOut(wsola, reg2, reg2_len);
			}
		}
		
		/* Get the region in buffer to be merged with the frame */
		if (reg2_len == 0) 
		{
			ola_left = reg1 + reg1_len - wsola->min_extra;
		}
		else if (reg2_len >= wsola->min_extra) 
		{
			ola_left = reg2 + reg2_len - wsola->min_extra;
		} 
		else 
		{
			DWORD tmp;
			
			tmp = wsola->min_extra - reg2_len;
			WsolaPortCopySamples(wsola->merge_buf, reg1 + reg1_len - tmp, tmp);
			WsolaPortCopySamples(wsola->merge_buf + tmp, reg2, reg2_len);
			ola_left = wsola->merge_buf;
		}
		
		/* Apply fade-in to the frame before merging */
		if ((wsola->options & WSOLA_OPTION_NO_FADING)==0)
		{
			DWORD count = wsola->min_extra;
			int fade_in_pos;
			
			/* Scale WsolaFadeIn position based on last fade-out */
			fade_in_pos = wsola->fade_out_pos * count /
				wsola->max_expand_cnt;
			
			/* Fade-in it */
			WsolaFadeIn(frm, wsola->samples_per_frame,
				fade_in_pos, count);
		}
		
		/* Merge it */
		WsolaOverlapAddSimple(frm, wsola->min_extra, ola_left, frm);
		
		/* Trim len */
		buf_len -= wsola->min_extra;
		WsolaBufSetLen(wsola->buf, buf_len);
		
	} 
	else if ((wsola->options & WSOLA_OPTION_NO_FADING)==0 &&
		   wsola->fade_out_pos != wsola->max_expand_cnt) 
	{
		DWORD count = wsola->min_extra;
		int fade_in_pos;
		
		/* Fade out the remaining synthetic samples */
		if (buf_len > wsola->hist_size)
		{
			short *reg1, *reg2;
			DWORD reg1_len, reg2_len;
			
			/* Number of samples to fade out */
			count = buf_len - wsola->hist_size;
			
			WsolaBufReadRegions(wsola->buf, &reg1, &reg1_len, 
				&reg2, &reg2_len);
			
			/* Continue applying fade out to the extra samples */
			if (reg2_len == 0) 
			{
				WsolaFadeOut(wsola, reg1 + reg1_len - count, count);
			} 
			else if ((int)reg2_len >= count) 
			{
				WsolaFadeOut(wsola, reg2 + reg2_len - count, count);
			}
			else
			{
				DWORD tmp = count - reg2_len;
				WsolaFadeOut(wsola, reg1 + reg1_len - tmp, tmp);
				WsolaFadeOut(wsola, reg2, reg2_len);
			}
		}
		
		/* Apply fade-in to the frame */
		count = wsola->min_extra;
		
		/* Scale WsolaFadeIn position based on last fade-out */
		fade_in_pos = wsola->fade_out_pos * count /
			wsola->max_expand_cnt;
		
		/* Fade it in */
		WsolaFadeIn(frm, wsola->samples_per_frame,
			fade_in_pos, count);
		
	}
	
	wsola->fade_out_pos = wsola->max_expand_cnt;
	
	status = WsolaBufWrite(wsola->buf, frm, wsola->samples_per_frame);
	if (status != RC_SUCCESS) 
	{
		kprintf("Failed writing to circbuf [err=%d]!\n", status);
		return status;
	}
	
	status = WsolaBufCopy(wsola->buf, wsola->hist_size, frm, 
		wsola->samples_per_frame);
	if (status != RC_SUCCESS) 
	{
		kprintf("Failed copying from circbuf [err=%d]!\n", status);
		return status;
	}
	
	return WsolaBufReadPtr(wsola->buf, wsola->samples_per_frame);
}


int WsolaGenerate(HANDLE hwsola, short frm[])
{
	DWORD samples_len, samples_req;
	WSOLA_OBJECT *wsola= (WSOLA_OBJECT*)hwsola;
	int status = RC_SUCCESS;

	/* Calculate how many samples in the buffer */
	samples_len = WsolaBufGetLen(wsola->buf) - wsola->hist_size;
	
	/* Calculate how many samples are required to be available in the buffer */
	samples_req = wsola->samples_per_frame + (wsola->min_extra << 1);
	
	if (samples_len < samples_req) 
	{
		/* Expand buffer */
		status = WsolaExpand(wsola, samples_req - samples_len);
		if(status != RC_SUCCESS)
			return status;
	}
	
	status = WsolaBufCopy(wsola->buf, wsola->hist_size, frm, 
		wsola->samples_per_frame);
	if (status != RC_SUCCESS)
	{
		kprintf("Failed copying from circbuf [err=%d]!\n", status);
		return status;
	}
	
	WsolaBufReadPtr(wsola->buf, wsola->samples_per_frame);
	
	/* Apply fade-out to the frame */
	if ((wsola->options & WSOLA_OPTION_NO_FADING)==0) 
	{
		WsolaFadeOut(wsola, frm, wsola->samples_per_frame);
	}
	
	return RC_SUCCESS;
}


int WsolaDiscard(HANDLE hwsola, short buf1[], DWORD buf1_cnt, 
					   short buf2[], DWORD buf2_cnt, DWORD *del_cnt)
{
	WSOLA_OBJECT *wsola= (WSOLA_OBJECT*)hwsola;
	if(!(wsola && buf1 && buf1_cnt && del_cnt))
		return RC_EINVAL;
	if(!(*del_cnt))
		return RC_EINVAL;

	if (buf2_cnt == 0) 
	{
		/* The whole buffer is contiguous space, straight away. */
		*del_cnt = WsolaCompress(wsola, buf1, buf1_cnt, *del_cnt);
	} 
	else 
	{
		if(!(buf2))
			return RC_EINVAL;
		
		if (buf1_cnt < ERASE_CNT * wsola->samples_per_frame &&
			buf2_cnt < ERASE_CNT * wsola->samples_per_frame &&
			wsola->erase_buf == NULL)
		{
		/* We need erase_buf but WSOLA was created with 
		* WSOLA_OPTION_NO_DISCARD flag.
			*/
			kprintf("WSOLA need erase buffer!\n");
			return RC_EINVALIDOP;
		}
		
		if (buf2_cnt >= ERASE_CNT * wsola->samples_per_frame) 
		{
			/* Enough space to perform WsolaCompress in the second buffer. */
			*del_cnt = WsolaCompress(wsola, buf2, buf2_cnt, *del_cnt);
		}
		else if (buf1_cnt >= ERASE_CNT * wsola->samples_per_frame)
		{
		/* Enough space to perform WsolaCompress in the first buffer, but then
		* we need to re-arrange the buffers so there is no gap between 
		* buffers.
			*/
			DWORD max;
			
			*del_cnt = WsolaCompress(wsola, buf1, buf1_cnt, *del_cnt);
			
			max = *del_cnt;
			if (max > buf2_cnt)
				max = buf2_cnt;
			
			WsolaPortMoveSamples(buf1 + buf1_cnt - (*del_cnt), buf2, max);
			
			if (max < buf2_cnt)
			{
				WsolaPortMoveSamples(buf2, buf2+(*del_cnt), 
					buf2_cnt-max);
			}
		} 
		else
		{
		/* Not enough samples in either buffers to perform WsolaCompress. 
		* Need to combine the buffers in a contiguous space, the erase_buf.
			*/
			DWORD buf_size = buf1_cnt + buf2_cnt;
			short *rem;	/* remainder */
			DWORD rem_cnt;
			
			if (buf_size > ERASE_CNT * wsola->samples_per_frame) 
			{
				buf_size = ERASE_CNT * wsola->samples_per_frame;
				
				rem_cnt = buf1_cnt + buf2_cnt - buf_size;
				rem = buf2 + buf2_cnt - rem_cnt;
				
			}
			else
			{
				rem = NULL;
				rem_cnt = 0;
			}
			
			WsolaPortCopySamples(wsola->erase_buf, buf1, buf1_cnt);
			WsolaPortCopySamples(wsola->erase_buf+buf1_cnt, buf2, 
				buf_size-buf1_cnt);
			
			*del_cnt = WsolaCompress(wsola, wsola->erase_buf, buf_size, *del_cnt);
			
			buf_size -= (*del_cnt);
			
			/* Copy back to buffers */
			if (buf_size == buf1_cnt) 
			{
				WsolaPortCopySamples(buf1, wsola->erase_buf, buf_size);
				if (rem_cnt)
				{
					WsolaPortMoveSamples(buf2, rem, rem_cnt);
				}
			} 
			else if (buf_size < buf1_cnt) 
			{
				WsolaPortCopySamples(buf1, wsola->erase_buf, buf_size);
				if (rem_cnt) 
				{
					DWORD c = rem_cnt;
					if (c > buf1_cnt-buf_size) 
					{
						c = buf1_cnt-buf_size;
					}
					WsolaPortCopySamples(buf1+buf_size, rem, c);
					rem += c;
					rem_cnt -= c;
					if (rem_cnt)
						WsolaPortMoveSamples(buf2, rem, rem_cnt);
				}
			} 
			else 
			{
				WsolaPortCopySamples(buf1, wsola->erase_buf, buf1_cnt);
				WsolaPortCopySamples(buf2, wsola->erase_buf+buf1_cnt, 
					buf_size-buf1_cnt);
				if (rem_cnt)
				{
					WsolaPortMoveSamples(buf2+buf_size-buf1_cnt, rem,
						rem_cnt);
				}
			}
			
		}
	}
	
	return (*del_cnt) > 0 ? RC_SUCCESS : RC_ETOOSMALL;
}


